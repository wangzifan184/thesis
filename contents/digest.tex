% !TEX root = ../main.tex

\begin{digest}
With the rapid development of new technologies such as containers and micro services, open source software has become the mainstream in the industry, and the software industry has developed rapidly

Exhibition. Most modern software is "assembled" rather than "developed". According to Forrester statistics, 80-90\% of the code in software development comes from open source software \ cite{Qianxin. Com}. Therefore, the source code of modern software is mostly mixed source code, which is composed of source code independently developed by enterprises and open source software code. Appbrain \ cite {appbrain} tracked 450 popular libraries, and the statistical results show that they are in the Android ecosystem

Mobile phone library is especially popular in the network and analysis system. Such extensive use of third-party libraries not only accelerates the development process and avoids repeated wheel building, but also attracts attackers to move their targets upstream of the software supply chain to attack applications by exploiting the vulnerabilities of popular libraries. Therefore, the detection of third-party database has become an urgent problem to be solved. The existing research methods can be divided into two categories: prior knowledge and no prior knowledge. The former needs the help of the standard third-party open source warehouse to achieve the detection goal through the extraction and matching of various features of the third-party library and the standard library in the app. The latter does not need external knowledge. Starting from the large-scale app data set and based on the clustering algorithm, the modules with class inheritance, function call and other connections are gathered together as the candidate database. When enough candidates appear and their similarity is high, they are considered to be from a third-party database. With the development of confusion technology, anti confusion has become a point that can not be ignored in research methods. Name based technology has been difficult to achieve satisfactory performance. In addition, the current research work on the detection of specific versions of third-party libraries is not much, and there are still some problems, such as how to accurately represent version differences and how to deal with large-scale data sets caused by a large number of versions.



Based on the above background, this paper proposes an Android application third-party library detection system TPL-V Detector based on a priori knowledge, which can resist confusion and be accurate to the specific version. In the system design, this paper first introduces the APK, jar and other files as the system input, as well as the DEX, class and bytecode files involved in the preprocessing process. Taking bytecode file as the input after processing, TPL-V Detector constructs a feature tree in the unit of package, and organizes all kinds of methods under the package and classes in the tree structure. Further, TPL-V Detector extracts the coarse-grained features based on function descriptors and the fine-grained features based on bytecode instruction sequences from bytecode files, calculates their hash values as the features of the method, and generates the features of classes according to the tree structure. The characteristics of the class are used to match the package. According to the similarity calculation method used in this paper, the package exceeding the threshold is regarded as the third-party library used in the detected app. The specific design details of TPL-V Detector are as follows.



TPL-V Detector can be divided into four modules: preprocessing, building feature tree, feature storage and feature matching. In the preprocessing module, APK and jar files are decompressed to obtain class files. Each class file corresponds to a class. Class file is further converted into bytecode file, which contains function descriptor, bytecode instruction sequence, constant pool and so on. In order to prevent confusion operations from changing the name, the return value name and parameter name in the function descriptor are deleted, only their types are retained, and the MD5 hash value of this string is calculated as the coarse-grained feature of the method. Due to the stack based nature of Java, bytecode instructions are operations on the stack and do not contain string classes. Therefore, connect the instruction sequences of a method and calculate the MD5 hash value as its fine-grained feature. Each path that contains a class file and its upper folder does not contain a class file is regarded as the root directory of a package, and a feature tree is constructed according to this directory and its contents. The root package is the root node of the tree, each type is the child node of the root, and each method under the class is the leaf node of this type of node. According to the tree structure, the features of the method are used to generate the features of the class. The specific method is to arrange and connect the features of the method according to the dictionary order, and calculate its fuzzy hash value as the result. For libraries from Maven central warehouse \ cite {Maven}, TPL-V Detector calculates their characteristics according to the above method and stores them in MySQL database. Each line records key information such as package name, class name, method name, characteristics of class and method. Records from Maven belong to the same design pattern as those from app and are stored in different tables under the same database. In the feature matching module, TPL-V Detector first uses coarse-grained features to select the class of the standard library with the highest similarity to its features in the database for each class in the app as its best match. The sum of the similarity of various best matches multiplied by the weight of the methods contained in them is the similarity score of the package. Packages that exceed the predefined threshold are regarded as a matching result of the current app package. After the package used by the app is detected, the fine-grained feature is further used to match versions within different versions of the package in the same way. In addition to the two-level feature strategy, based on the assumption that most classes belonging to the same package are placed in the same folder, TPL-V Detector also introduces the strategy of priority queue, which puts several best matching results of the class to be matched in the current app into the priority queue. When the class to be matched arrives, it is likely to find a match with high similarity in the priority queue.



Multiple experiments were conducted to detect the performance of TPL-V Detector. Firstly, experiments were carried out on the standard third-party database dataset from Maven. For the six selected libraries and their different versions, the experiment used Proguard to confuse them. The matching similarity of the best results of TPL-V Detector on each library can reach more than 0.8, which is much higher than the non best results, indicating that TPL-V Detector has excellent feature extraction and processing ability, and can easily distinguish different libraries even in the case of confusion. Then, the detection performance is evaluated on the actual android app. Firstly, the best experimental parameters are selected by depicting the change curve of each index with the threshold. For the 10 selected apps and the 9 third-party libraries used therein, TPL-V Detector detected most of them, and only performed poorly in individual libraries with a very large number of versions, reaching an accuracy rate of 88.0\% and a recall rate of 81.5\%. The experiment then discusses TPL-V Detector in detail. Firstly, the time cost of its four stages is evaluated. The construction of feature tree and feature generation take less time. In app preprocessing stage, due to the need to call third-party programs many times, it reaches 60\% ~ 70\% of the total time cost. In addition, the experiment also discusses the optimization effect of two-level feature and priority queue matching strategies. The time optimization of two-level feature on feature matching stage is very obvious. According to the size of database, the time can be shortened to 1 / 2 to 1 / 5 without any strategy. Priority queue can further optimize the time overhead on the premise of applying two-level characteristic strategy. Finally, the comparative experiment between TPL-V Detector and existing tools is carried out. Combined with the indicators of accuracy, recall and F1 score, TPL-V Detector has achieved the best performance.



In general, the contributions of this paper are as follows.(1) This paper proposes TPL-V Detector, a third-party library detection system, which can not only accurately identify the third-party library, but also accurate to the specific version. (2) This paper proposes a feature generation method based on descriptor type and bytecode instruction sequence, which makes TPL-V Detector still have a good performance in detecting confused apps. (3) This paper introduces the coarse / fine-grained features, and adds the priority queue strategy in the process of database matching, which effectively optimizes the simple matching method and saves time. (4) This paper evaluates on Maven data set, which can accurately match the SDK before and after confusion one by one, and achieve 100\% accuracy under the invitation of more than 200 versions in 6 libraries. (5) In this paper, the experimental test is carried out with the self built app data set, and the time overhead in different stages is analyzed in detail. Considering many factors such as version recognition and accuracy, it has good performance, and the accuracy is as high as 98%.



To sum up, this paper proposes an Android application third-party library and its version detection system based on a priori knowledge and anti confusion, which has achieved good performance in the experimental evaluation and achieved the expected research goal of the subject.

\end{digest}
